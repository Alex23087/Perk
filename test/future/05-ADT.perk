// type Point = Point(int, int)

type List = | Empty | Cons(int, List) | Leaf (int)

// enum List<T> {
//     Empty,
//     Cons(T, List<T>)
// }

// fun length(l: List): int {
//     match (l) {
//         Empty { return 0 },
//         Cons(_, (Cons(_, tail))) { return 2 + length(tail) },
//         Cons(_, tail) { return 1 + length(tail) }
//         Leaf(12) { return 1 },
//         Leaf(_) { return 1 }
//     }
// }

// int length(List l)
// {
//     switch (l.tag)
//     {
//         case __perk_Empty_Tag:{
//             return 0;
//         }
        
//         case __perk_Cons_Tag:{
//             switch (l.data.Cons._1->tag)
//             {
//                 case __perk_Cons_Tag: {
//                     List tail = *l.data.Cons._1;
//                     return 2 + length(tail);
//                 }                
//             }
//             List tail = *l.data.Cons._1;
//             return 1 + length(tail);
//         }

//         case __perk_Leaf_Tag:{
//             if (l.data.Leaf._0 == 12) {
//                 return 1;
//             }
//             return 1;
//         }
//     }
// }

fun main(): void {
    let l :List = Cons (10, Empty());
    let l2 : List = Empty;
    skip;

    match (l) {
        Empty {
            skip
        }
        Cons(x, _) {
          skip
        }
        default {
          skip
        }
    }
}
