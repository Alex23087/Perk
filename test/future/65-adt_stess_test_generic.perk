//Same as test/pass/65-generic-adt-stress.perk but with generic type parameters where possible, to further stress the ADT implementation and generic handling.

import "stdio.h"

// A polymorphic linked list used as a building block for other ADTs.
type <T> list = Nil | Cons(T, list @ T)

// Queue implemented with two lists (front/back) to exercise nested generic ADTs.
type <T> queue = Queue(list @ T, list @ T)
// Result ADT for queue pop, similar to an option carrying the updated queue.
type <T> pop_result = EmptyPop | Popped(T, queue @ T)

// Standard optional value ADT.
type <T> option = None | Some(T)

// Lazy/eager value ADT to test generic function values in constructors.
type <T> thunk = Ready(T) | Deferred(() => T)

// Polymorphic binary tree ADT.
type <T> tree = Leaf(T) | Node(tree @ T, tree @ T)

// Tail-recursive reverse-append on lists.
fun <T> list_reverse_append(xs: list @ T, acc: list @ T): list @ T {
    match (xs) {
        Nil {
            return acc
        },
        Cons(var hd, var tl) {
            return list_reverse_append @ T (tl, Cons @ T (hd, acc))
        }
    }
}

fun <T> list_reverse(xs: list @ T): list @ T {
    return list_reverse_append @ T (xs, Nil @ T)
}

// Create an empty queue.
fun <T> queue_empty(): queue @ T {
    return Queue @ T (Nil @ T, Nil @ T)
}

// Keep invariant: if front is empty, move reversed back into front.
fun <T> queue_normalize(q: queue @ T): queue @ T {
    match (q) {
        Queue(Nil, var back) {
            return Queue @ T (list_reverse @ T (back), Nil @ T)
        },
        _ {
            return q
        }
    }
}

fun <T> queue_push(q: queue @ T, value: T): queue @ T {
    match (q) {
        Queue(var front, var back) {
            return queue_normalize @ T (Queue @ T (front, Cons @ T (value, back)))
        }
    }
}

fun <T> queue_pop(q: queue @ T): pop_result @ T {
    let normalized := queue_normalize @ T (q);
    match (normalized) {
        Queue(Nil, _) {
            return EmptyPop @ T
        },
        Queue(Cons(var hd, var tl), var back) {
            return Popped @ T (hd, Queue @ T (tl, back))
        }
    }
}

// Consume an entire int queue and sum all values.
fun drain_sum(q: queue @ int): int {
    match (queue_pop @ int (q)) {
        EmptyPop {
            return 0
        },
        Popped(var head, var rest) {
            return head + drain_sum(rest)
        }
    }
}

// Evaluate a thunk (either directly available or deferred in a lambda).
fun <T> force(t: thunk @ T): T {
    match (t) {
        Ready(var value) {
            return value
        },
        Deferred(var f) {
            return f()
        }
    }
}

// Map an endomorphism over an option.
fun <T> option_map(o: option @ T, f: (T) => T): option @ T {
    match (o) {
        None {
            return o
        },
        Some(var value) {
            return Some @ T (f(value))
        }
    }
}

// Map an endomorphism over all tree leaves.
fun <T> tree_map(t: tree @ T, f: (T) => T): tree @ T {
    match (t) {
        Leaf(var value) {
            return Leaf @ T (f(value))
        },
        Node(var left, var right) {
            return Node @ T (
                tree_map @ T (left, f),
                tree_map @ T (right, f)
            )
        }
    }
}

// Generic fold over a tree, used here with int but defined polymorphically.
fun <T> tree_fold(f: (T, T) => T, acc: T, t: tree @ T): T {
    match (t) {
        Leaf(var value) {
            return f(value, acc)
        },
        Node(var left, var right) {
            let acc1 := tree_fold @ T (f, acc, left);
            return tree_fold @ T (f, acc1, right)
        }
    }
}

fun main(): void {
    // Build queue [1,2,3,4,5,6] through repeated pushes.
    let q0 := queue_empty @ int ();
    let q1 := queue_push @ int (q0, 1);
    let q2 := queue_push @ int (q1, 2);
    let q3 := queue_push @ int (q2, 3);
    let q4 := queue_push @ int (q3, 4);
    let q5 := queue_push @ int (q4, 5);
    let q6 := queue_push @ int (q5, 6);

    // Pop two elements (tests nested matches and ADT destructuring).
    match (queue_pop @ int (q6)) {
        EmptyPop {
            printf("unexpected empty queue\n");
        },
        Popped(var first, var rest1) {
            printf("queue first: %d\n", first);

            match (queue_pop @ int (rest1)) {
                EmptyPop {
                    printf("unexpected queue tail empty\n");
                },
                Popped(var second, var rest2) {
                    printf("queue second: %d\n", second);

                    let remaining := drain_sum(rest2);
                    printf("queue remaining sum: %d\n", remaining);

                    // Build and force a deferred computation.
                    let delayed := Deferred @ int (() : int { return first + second + remaining });
                    let forced := force @ int (delayed);
                    printf("forced thunk: %d\n", forced);

                    // Map over option and pattern-match the result.
                    let lifted := option_map @ int (Some @ int (first), (x: int): int { return x + forced });
                    match (lifted) {
                        None {
                            printf("mapped option: none\n");
                        },
                        Some(var value) {
                            printf("mapped option: %d\n", value);
                        }
                    };

                    // Build a tree from queue-derived values, map, then fold it.
                    let raw_tree := Node @ int (Leaf @ int (first), Node @ int (Leaf @ int (second), Leaf @ int (remaining)));
                    let doubled_tree := tree_map @ int (raw_tree, (x: int): int { return x * 2 });
                    let tree_sum := tree_fold @ int ((x: int, acc: int): int { return x + acc }, 0, doubled_tree);
                    printf("tree sum: %d\n", tree_sum);
                }
            }
        }
    }
}
